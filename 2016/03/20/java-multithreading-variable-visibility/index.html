<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;dark&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png"><link rel="icon" href="/img/favicon.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content="记录一下 Java 多线程可见性问题"><meta name="author" content="bleem"><meta name="keywords" content="多线程,Java,可见性"><title>Java 多线程可见性问题 - bleem</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/atom-one-dark-reasonable.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"mritd.com",root:"/",version:"1.8.11",typing:{enable:!0,typeSpeed:80,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:200}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:3},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:null,google:"UA-179552593-1",gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="bleem" type="application/atom+xml">
<link rel="alternate" href="/rss.xml" title="bleem" type="application/rss+xml">
</head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>bleem</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/friends/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(/img/default.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="Java 多线程可见性问题"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2016-03-20 15:04" pubdate>2016年3月20日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 2.1k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 24 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">Java 多线程可见性问题</h1><div class="markdown-body"><h2 id="一、相关定义"><a href="#一、相关定义" class="headerlink" title="一、相关定义"></a>一、相关定义</h2><h3 id="1、可见性"><a href="#1、可见性" class="headerlink" title="1、可见性"></a>1、可见性</h3><p>在多线程中，如果一个线程对某一 <strong>共享变量</strong> 的修改，<strong>能及时被其他线程所感知</strong>，这个特性或者说过程称之为线程可见性。</p><h3 id="2、共享变量"><a href="#2、共享变量" class="headerlink" title="2、共享变量"></a>2、共享变量</h3><p>当多线程同时操作一个变量时，该变量在多线程的 <strong>工作内存(私有内存)</strong> 中都存在一个副本，那么这个变量称之为这几个线程的共享变量。</p><h3 id="3、工作内存"><a href="#3、工作内存" class="headerlink" title="3、工作内存"></a>3、工作内存</h3><p>多线程工作时，每个线程都会复制主内存中的变量副本到自己的私有内存，这个私有内存称之为每个线程的工作内存。</p><h2 id="二、Java-内存模型-Java-Memory-Model"><a href="#二、Java-内存模型-Java-Memory-Model" class="headerlink" title="二、Java 内存模型(Java Memory Model)"></a>二、Java 内存模型(Java Memory Model)</h2><blockquote><p><strong>Java 内存模型(JMM) 描述了 Java 程序中对线程共享变量的访问规则，以及在 JVM 层面对内存读写变量的底层细节，详细可参考 <a target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/java-memory-model-1">InfoQ-深入理解Java内存模型</a></strong></p></blockquote><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p>简单地说，Java 内存模型规定，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享，局部变量(Local variables)，方法定义参数(java语言规范称之为formal method parameters)和异常处理器参数(exception handler parameters)不会在线程之间共享；运行时将所有变量放入 <strong>主内存中</strong>，同时在多线程访问的情况下，每个线程会开辟自己的 <strong>工作内存(抽象)<strong>；</strong>工作内存中用于存放该线程所用到的每个主内存中的变量副本</strong>，图例如下：</p><p><img src="https://cdn.oss.link/markdown/hexo_java_thread_memory1.png" srcset="/img/loading.gif" lazyload alt="Java 内存模型1"></p><h3 id="2、线程读写变量规则"><a href="#2、线程读写变量规则" class="headerlink" title="2、线程读写变量规则"></a>2、线程读写变量规则</h3><p>JMM 规定，多线程情况下，每个线程对变量的操作 <strong>必须在自己的工作内存</strong> 中完成，<strong>不允许线程直接对主内存进行操作</strong>。</p><p>多线程变量传递需要借助主内存中转；<strong>也就是说，当A线程需要改变变量值时，需要先改变当前工作内存中的变量，再将其刷新到主内存，最后通过主内存刷新到线程B的工作内存。</strong>图例如下：</p><p><img src="https://cdn.oss.link/markdown/hexo_java_thread_memory2.png" srcset="/img/loading.gif" lazyload alt="Java 内存模型2"></p><p><img src="https://cdn.oss.link/markdown/hexo_java_thread_memory3.png" srcset="/img/loading.gif" lazyload alt="Java 内存模型3"></p><h2 id="三、synchronized-实现可见性"><a href="#三、synchronized-实现可见性" class="headerlink" title="三、synchronized 实现可见性"></a>三、synchronized 实现可见性</h2><p>Java 中对代码块或方法使用 <code>symchroized</code> 关键字，可保证其内部的共享变量实现多线程可见性。</p><h3 id="1、JMM-对-synchroized-相关规定"><a href="#1、JMM-对-synchroized-相关规定" class="headerlink" title="1、JMM 对 synchroized 相关规定"></a>1、JMM 对 synchroized 相关规定</h3><ul><li>线程解锁前，必须将工作内存中数据刷新到主内存。</li><li>线程加锁时，必须先清空工作内存，然后将主内存数据刷新到工作内存</li></ul><h3 id="2、线程执行互斥代码过程"><a href="#2、线程执行互斥代码过程" class="headerlink" title="2、线程执行互斥代码过程"></a>2、线程执行互斥代码过程</h3><ul><li>1、线程在 <code>synchroized</code> 入口处获得互斥锁</li><li>2、线程清空自己的工作内存</li><li>3、线程将主内存数据刷新到工作内存</li><li>4、线程执行互斥代码</li><li>5、线程将工作内存数据刷新到主内存</li><li>6、线程退出 <code>synchroized</code> 代码块并释放互斥锁</li></ul><h3 id="3、指令重排序"><a href="#3、指令重排序" class="headerlink" title="3、指令重排序"></a>3、指令重排序</h3><blockquote><p>具体可参考 <a target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/java-memory-model-2">InfoQ 深入理解Java内存模型（二）-重排序</a></p></blockquote><p><strong>定义：</strong>指令重排序，简单地说就是编译器和CPU为了提高并行执行速度，进行的代码重排序执行。</p><p>在CPU执行层面，每执行一个指令也会类似 Java 语言的 I/O 操作，在某一个命令未执行完成时必须进入等待(阻塞状态)，然后执行下一个命令；而编译器和CPU为了最大限度利用有限时间执行更多的任务，可能会进行指令重排序；指令重排序结果如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 原有代码</span>
<span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;
<span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;</code></pre></div><p>在编译器和CPU优化后，重排序可能会出现如下结果：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 重排序后</span>
<span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;
<span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;</code></pre></div><p><strong>但是指令重排序会遵循一点：as-if-serail 语义，即在单线程的情况下，保证最终执行结果不变，这时才会进行指令重排序；</strong>如上所示，a与b哪个先定义都不会产生结果的变更时才会重排序。</p><h3 id="4、代码示例"><a href="#4、代码示例" class="headerlink" title="4、代码示例"></a>4、代码示例</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> mkw.demo.syn;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedDemo</span> </span>&#123;
	<span class="hljs-comment">//共享变量</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> ready = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">1</span>;   
    <span class="hljs-comment">//写操作</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span></span>&#123;
    	ready = <span class="hljs-keyword">true</span>;	      		 <span class="hljs-comment">//1.1				</span>
    	number = <span class="hljs-number">2</span>;                      <span class="hljs-comment">//1.2			    </span>
    &#125;
    <span class="hljs-comment">//读操作</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;			   	 
    	<span class="hljs-keyword">if</span>(ready)&#123;		         <span class="hljs-comment">//2.1</span>
    		result = number*<span class="hljs-number">3</span>;	 <span class="hljs-comment">//2.2</span>
    	&#125;   	
    	System.out.println(<span class="hljs-string">&quot;result的值为：&quot;</span> + result);
    &#125;

    <span class="hljs-comment">//内部线程类</span>
    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadWriteThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;
    	<span class="hljs-comment">//根据构造方法中传入的flag参数，确定线程执行读操作还是写操作</span>
    	<span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> flag;
    	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReadWriteThread</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> flag)</span></span>&#123;
    		<span class="hljs-keyword">this</span>.flag = flag;
    	&#125;
        <span class="hljs-meta">@Override</span>                                                                    
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
        	<span class="hljs-keyword">if</span>(flag)&#123;
        		<span class="hljs-comment">//构造方法中传入true，执行写操作</span>
        		write();
        	&#125;<span class="hljs-keyword">else</span>&#123;
        		<span class="hljs-comment">//构造方法中传入false，执行读操作</span>
        		read();
        	&#125;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span>&#123;
    	SynchronizedDemo synDemo = <span class="hljs-keyword">new</span> SynchronizedDemo();
    	<span class="hljs-comment">//启动线程执行写操作</span>
    	synDemo .<span class="hljs-function">new <span class="hljs-title">ReadWriteThread</span><span class="hljs-params">(<span class="hljs-keyword">true</span>)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span></span>;
    	<span class="hljs-comment">//启动线程执行读操作</span>
    	synDemo.<span class="hljs-function">new <span class="hljs-title">ReadWriteThread</span><span class="hljs-params">(<span class="hljs-keyword">false</span>)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span></span>;
    &#125;
&#125;</code></pre></div><p>运行 mian 方法，由于可见性问题，可能出现多种情况，比如 写线程执行到 1.1，读线程获取CPU资源立即执行、写线程指令 1.1、1.2重排序等等情况。</p><h2 id="四、volatile-实现可见性控制"><a href="#四、volatile-实现可见性控制" class="headerlink" title="四、volatile 实现可见性控制"></a>四、volatile 实现可见性控制</h2><h3 id="1、实现原理"><a href="#1、实现原理" class="headerlink" title="1、实现原理"></a>1、实现原理</h3><p>volatile 通过加入内存屏障和禁止指令重排序实现可见性控制，其过程大致分为以下两个过程：</p><ul><li>对 volatile 变量进行写操作时，会在写操作后加入一条 <code>store</code> 屏蔽指令；<strong>该命令会将工作内存中内容强制刷新到主内存(覆盖)；同时会防止编译器/CPU指令重排序时将前面的变量重排到 volatile 修饰的变量之后(禁止颠倒顺序)。</strong></li><li>对 volatile 变量进行读操作时，会在读操作前加入一条 <code>load</code> 屏蔽指令；<strong>该指令会强制使工作内存失效，从而达到必须从主内存刷新到工作内存的效果</strong></li></ul><p>总结：使用 valotile 修饰变量后，线程在每次读取该变量时，会强制从主内存刷新最新状态到工作内存；在每次写入该变量时，会强制从工作内存刷新到主内存，以保证线程可见性。</p><h3 id="2、volatile-不能保证原子性"><a href="#2、volatile-不能保证原子性" class="headerlink" title="2、volatile 不能保证原子性"></a>2、volatile 不能保证原子性</h3><p>由上可知 volatile 在保证可见性的原理大致和 synchroized 类似，主要是控制工作内存与主内存的刷新关系；但是相对于 synchroized ，volatile 不能保证原子性操作，测试代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> mkw.demo.vol;

<span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileDemo</span> </span>&#123;

        <span class="hljs-comment">// 测试变量</span>
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumber</span><span class="hljs-params">()</span></span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.number;
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase</span><span class="hljs-params">()</span></span>&#123;
		<span class="hljs-keyword">try</span> &#123;
			Thread.sleep(<span class="hljs-number">100</span>);
		&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
			e.printStackTrace();
		&#125;

		<span class="hljs-keyword">this</span>.number++;
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		<span class="hljs-comment">// TODO Auto-generated method stub</span>
		<span class="hljs-keyword">final</span> VolatileDemo volDemo = <span class="hljs-keyword">new</span> VolatileDemo();
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">500</span> ; i++)&#123;
			<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;

				<span class="hljs-meta">@Override</span>
				<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
					volDemo.increase();
				&#125;
			&#125;).start();
		&#125;

		<span class="hljs-comment">//如果还有子线程在运行，主线程就让出CPU资源，</span>
		<span class="hljs-comment">//直到所有的子线程都运行完了，主线程再继续往下执行</span>
		<span class="hljs-keyword">while</span>(Thread.activeCount() &gt; <span class="hljs-number">1</span>)&#123;
			Thread.yield();
		&#125;

		System.out.println(<span class="hljs-string">&quot;number : &quot;</span> + volDemo.getNumber());
	&#125;

&#125;</code></pre></div><p>当以上代码运行多次后，number 打印的值会出现很多小于500的情况；其原因是 volatile 无法保证 number++ 这行代码的原子性操作；实质上 <code>number++</code> 执行了3个动作，首先读取 number 值，然后进行+1，最后写会 number；</p><p>首先假设 number=2，在多线程并发的情况下，A线程由于 volatile 原因，首先将 number 从主内存强制刷新到工作内存，然后进行 +1 操作，此时A线程工作内存中 number=3，当要回写到工作内存时。线程 B 获取了CPU资源开始执行；不难想象，B线程对 number+1 后，可能被A线程覆盖掉；此时 volatile 无法保证原子性的问题就暴露了出来。</p><h3 id="3、volatile-适用场景"><a href="#3、volatile-适用场景" class="headerlink" title="3、volatile 适用场景"></a>3、volatile 适用场景</h3><ul><li>对变量的写不依赖于当前值；即直接强制写，同时写的值跟上一次没关系。</li><li>该变量不包含在其他变量的不变式中；即与其他 volatile 变量没关系。</li></ul><h3 id="4、volatile-与-synchroized-比较"><a href="#4、volatile-与-synchroized-比较" class="headerlink" title="4、volatile 与 synchroized 比较"></a>4、volatile 与 synchroized 比较</h3><p>在可见性上，volatile 与 synchroized 基本是相同的；但是在原子性上，volatile不支持；<strong>同时 synchroized 会执行加锁动作，开销较大，而 volatile 更轻量级。</strong></p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/java/">Java</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/java/">Java</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 国际许可协议进行许可，转载请注明出处。</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2016/03/21/java-memory-java-heap/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Java 内存之 Java 堆</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2016/03/14/sql-or-keyword-priority/"><span class="hidden-mobile">SQL中 OR 关键字优先级问题</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments" lazyload><div class="disqus" style="width:100%"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config=function(){this.page.url="https://mritd.com/2016/03/20/java-multithreading-variable-visibility/",this.page.identifier="/2016/03/20/java-multithreading-variable-visibility/"};Fluid.utils.loadComments("#disqus_thread",(function(){var i=document,t=i.createElement("script");t.src="//bleem.disqus.com/embed.js",t.setAttribute("data-timestamp",new Date),(i.head||i.body).appendChild(t)}))</script><noscript>Please enable JavaScript to view the comments</noscript></div></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:200}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script src="/js/local-search.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script defer>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-179552593-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script src="/js/boot.js"></script></body></html>